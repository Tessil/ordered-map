<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ordered-map: tsl::ordered_set&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ordered-map
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetsl.html">tsl</a></li><li class="navelem"><a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classtsl_1_1ordered__set-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tsl::ordered_set&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="ordered__set_8h_source.html">ordered_set.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a02fb4e2e15f314f6ac35c214d9df23ef"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a02fb4e2e15f314f6ac35c214d9df23ef">key_type</a> = typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#aa14641f4be3e4aca317b1cb0a8bbded4">ht::key_type</a></td></tr>
<tr class="separator:a02fb4e2e15f314f6ac35c214d9df23ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3852aebb63dcde9d151859cb65f951e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#aa3852aebb63dcde9d151859cb65f951e">value_type</a> = typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#a675a898ce63c4df6ea9ab7db1a8ffa7a">ht::value_type</a></td></tr>
<tr class="separator:aa3852aebb63dcde9d151859cb65f951e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2679e2e7b1ac5583afe30254f3fe2391"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a> = typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#a77c1ebd8a153b092abd1513aeed8b838">ht::size_type</a></td></tr>
<tr class="separator:a2679e2e7b1ac5583afe30254f3fe2391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74aabf02f8feedcae29dc7486d764a9b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a74aabf02f8feedcae29dc7486d764a9b">difference_type</a> = typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#af2a6592e3f27b098824e1c3ae2b7c80f">ht::difference_type</a></td></tr>
<tr class="separator:a74aabf02f8feedcae29dc7486d764a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5223d8468abce9948f98b3b95d1e982c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a5223d8468abce9948f98b3b95d1e982c">hasher</a> = typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#aec06904df31ad580930684637da4a733">ht::hasher</a></td></tr>
<tr class="separator:a5223d8468abce9948f98b3b95d1e982c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c68662e5e311f48f70ace69759342f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a13c68662e5e311f48f70ace69759342f">key_equal</a> = typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#a61a5c29ff6c4378ad1efba76b26228cb">ht::key_equal</a></td></tr>
<tr class="separator:a13c68662e5e311f48f70ace69759342f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fbfaf193b1d445d0947dfc5678b6855"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a8fbfaf193b1d445d0947dfc5678b6855">allocator_type</a> = typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#ab11ec82b2c02993170fa5645797bf6f5">ht::allocator_type</a></td></tr>
<tr class="separator:a8fbfaf193b1d445d0947dfc5678b6855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958a0120052bda326fb7bf72e9878a5c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a958a0120052bda326fb7bf72e9878a5c">reference</a> = typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#af89a4de3e6c41488b2b29fbeea4682db">ht::reference</a></td></tr>
<tr class="separator:a958a0120052bda326fb7bf72e9878a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213465f357963c30b084451ad61299ac"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a213465f357963c30b084451ad61299ac">const_reference</a> = typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#a3ef2c7c6e46c43ce02aed27f44c30452">ht::const_reference</a></td></tr>
<tr class="separator:a213465f357963c30b084451ad61299ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274eb7795de5ce31fa932e97ccb255cb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a274eb7795de5ce31fa932e97ccb255cb">pointer</a> = typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#ac4e053f630b968f7bf8d21bc00aed068">ht::pointer</a></td></tr>
<tr class="separator:a274eb7795de5ce31fa932e97ccb255cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bd3a5ea8376cdc30c81eb93283b352b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a3bd3a5ea8376cdc30c81eb93283b352b">const_pointer</a> = typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#a584cb2f4d6e7e7e8e1356a31677f24ec">ht::const_pointer</a></td></tr>
<tr class="separator:a3bd3a5ea8376cdc30c81eb93283b352b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b02aa2270e720edf5b8a30b106e7346"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a> = typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#a67c369d7edd1131bf9e0a8ada4e4d094">ht::iterator</a></td></tr>
<tr class="separator:a6b02aa2270e720edf5b8a30b106e7346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1996923ed0d9b62d7d959af57a1be3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a> = typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#a6dbac93fb19be2c2e929489fb0b5c385">ht::const_iterator</a></td></tr>
<tr class="separator:a3a1996923ed0d9b62d7d959af57a1be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850e708a94572268b80d79d8238c74fd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a850e708a94572268b80d79d8238c74fd">reverse_iterator</a> = typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#aa7801013d5f330513e4d9743b40f8cf1">ht::reverse_iterator</a></td></tr>
<tr class="separator:a850e708a94572268b80d79d8238c74fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4cdc912734a2b6757cbb816ab2657ea"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#ac4cdc912734a2b6757cbb816ab2657ea">const_reverse_iterator</a> = typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#a2f2940b46a61dc1af261e2a40904a7b0">ht::const_reverse_iterator</a></td></tr>
<tr class="separator:ac4cdc912734a2b6757cbb816ab2657ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68942b7edb65da7c0ec756b7172f497"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#af68942b7edb65da7c0ec756b7172f497">values_container_type</a> = typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#ad907d82adf51d0502fe818a7131a0936">ht::values_container_type</a></td></tr>
<tr class="separator:af68942b7edb65da7c0ec756b7172f497"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a700b6bf2da365f1e04c1d35190567024"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a700b6bf2da365f1e04c1d35190567024">ordered_set</a> ()</td></tr>
<tr class="separator:a700b6bf2da365f1e04c1d35190567024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec2418fd9c2d4ee6ee02f7b4fa0caa1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a4ec2418fd9c2d4ee6ee02f7b4fa0caa1">ordered_set</a> (<a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html#ad9889c1abde8a4980dcedca11a4da90a">bucket_count</a>, const Hash &amp;hash=Hash(), const KeyEqual &amp;equal=KeyEqual(), const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="separator:a4ec2418fd9c2d4ee6ee02f7b4fa0caa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a2c776d606ff253b16ded3ebc50f081"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a0a2c776d606ff253b16ded3ebc50f081">ordered_set</a> (<a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html#ad9889c1abde8a4980dcedca11a4da90a">bucket_count</a>, const Allocator &amp;alloc)</td></tr>
<tr class="separator:a0a2c776d606ff253b16ded3ebc50f081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab684dbea1303cf3173ea839eee34fd44"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#ab684dbea1303cf3173ea839eee34fd44">ordered_set</a> (<a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html#ad9889c1abde8a4980dcedca11a4da90a">bucket_count</a>, const Hash &amp;hash, const Allocator &amp;alloc)</td></tr>
<tr class="separator:ab684dbea1303cf3173ea839eee34fd44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721a7fcbb629b9c000c2e77925b4fa36"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a721a7fcbb629b9c000c2e77925b4fa36">ordered_set</a> (const Allocator &amp;alloc)</td></tr>
<tr class="separator:a721a7fcbb629b9c000c2e77925b4fa36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad057518e7311f0437ec1f7b059525bd"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:aad057518e7311f0437ec1f7b059525bd"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#aad057518e7311f0437ec1f7b059525bd">ordered_set</a> (InputIt first, InputIt last, <a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html#ad9889c1abde8a4980dcedca11a4da90a">bucket_count</a>=<a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#abef368126aac0177fcf90d85c63eedef">ht::DEFAULT_INIT_BUCKETS_SIZE</a>, const Hash &amp;hash=Hash(), const KeyEqual &amp;equal=KeyEqual(), const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="separator:aad057518e7311f0437ec1f7b059525bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1925811490371805e060c1488063a545"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a1925811490371805e060c1488063a545"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a1925811490371805e060c1488063a545">ordered_set</a> (InputIt first, InputIt last, <a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html#ad9889c1abde8a4980dcedca11a4da90a">bucket_count</a>, const Allocator &amp;alloc)</td></tr>
<tr class="separator:a1925811490371805e060c1488063a545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040a736e5534ba4a3c0467779df0b26b"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a040a736e5534ba4a3c0467779df0b26b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a040a736e5534ba4a3c0467779df0b26b">ordered_set</a> (InputIt first, InputIt last, <a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html#ad9889c1abde8a4980dcedca11a4da90a">bucket_count</a>, const Hash &amp;hash, const Allocator &amp;alloc)</td></tr>
<tr class="separator:a040a736e5534ba4a3c0467779df0b26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af15847bafa2827f9558ff3113ce3c047"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#af15847bafa2827f9558ff3113ce3c047">ordered_set</a> (std::initializer_list&lt; <a class="el" href="classtsl_1_1ordered__set.html#aa3852aebb63dcde9d151859cb65f951e">value_type</a> &gt; init, <a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html#ad9889c1abde8a4980dcedca11a4da90a">bucket_count</a>=<a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#abef368126aac0177fcf90d85c63eedef">ht::DEFAULT_INIT_BUCKETS_SIZE</a>, const Hash &amp;hash=Hash(), const KeyEqual &amp;equal=KeyEqual(), const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="separator:af15847bafa2827f9558ff3113ce3c047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3756674af513e07365ea58a4307ea068"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a3756674af513e07365ea58a4307ea068">ordered_set</a> (std::initializer_list&lt; <a class="el" href="classtsl_1_1ordered__set.html#aa3852aebb63dcde9d151859cb65f951e">value_type</a> &gt; init, <a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html#ad9889c1abde8a4980dcedca11a4da90a">bucket_count</a>, const Allocator &amp;alloc)</td></tr>
<tr class="separator:a3756674af513e07365ea58a4307ea068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ada7c8348ee664b0c8d51c241ce3c82"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a4ada7c8348ee664b0c8d51c241ce3c82">ordered_set</a> (std::initializer_list&lt; <a class="el" href="classtsl_1_1ordered__set.html#aa3852aebb63dcde9d151859cb65f951e">value_type</a> &gt; init, <a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html#ad9889c1abde8a4980dcedca11a4da90a">bucket_count</a>, const Hash &amp;hash, const Allocator &amp;alloc)</td></tr>
<tr class="separator:a4ada7c8348ee664b0c8d51c241ce3c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e545a2e1c9252da9aafd3b8d9027996"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a4e545a2e1c9252da9aafd3b8d9027996">operator=</a> (std::initializer_list&lt; <a class="el" href="classtsl_1_1ordered__set.html#aa3852aebb63dcde9d151859cb65f951e">value_type</a> &gt; ilist)</td></tr>
<tr class="separator:a4e545a2e1c9252da9aafd3b8d9027996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ee92e0575ea5eda52000fa7359e19a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a8fbfaf193b1d445d0947dfc5678b6855">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a43ee92e0575ea5eda52000fa7359e19a">get_allocator</a> () const</td></tr>
<tr class="separator:a43ee92e0575ea5eda52000fa7359e19a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13854981a0a6dcf3caa8681249c8a2a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a13854981a0a6dcf3caa8681249c8a2a6">begin</a> () noexcept</td></tr>
<tr class="separator:a13854981a0a6dcf3caa8681249c8a2a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bcc4e4dd0290e5e95ac5581a90877d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a8bcc4e4dd0290e5e95ac5581a90877d7">begin</a> () const noexcept</td></tr>
<tr class="separator:a8bcc4e4dd0290e5e95ac5581a90877d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10355d72c3d4c1ab5c3995612239f40f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a10355d72c3d4c1ab5c3995612239f40f">cbegin</a> () const noexcept</td></tr>
<tr class="separator:a10355d72c3d4c1ab5c3995612239f40f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa697b0fafb7028551f4d4f66381ca8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a5aa697b0fafb7028551f4d4f66381ca8">end</a> () noexcept</td></tr>
<tr class="separator:a5aa697b0fafb7028551f4d4f66381ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2eb040a0129c07e9735448b114ab5e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#aa2eb040a0129c07e9735448b114ab5e8">end</a> () const noexcept</td></tr>
<tr class="separator:aa2eb040a0129c07e9735448b114ab5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54476254fe316471d65ff77a73941fb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a54476254fe316471d65ff77a73941fb5">cend</a> () const noexcept</td></tr>
<tr class="separator:a54476254fe316471d65ff77a73941fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e062f9c1505b58ad17726d9accdfa21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a850e708a94572268b80d79d8238c74fd">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a5e062f9c1505b58ad17726d9accdfa21">rbegin</a> () noexcept</td></tr>
<tr class="separator:a5e062f9c1505b58ad17726d9accdfa21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b6e77078a912cfaea9ebc45e876aea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#ac4cdc912734a2b6757cbb816ab2657ea">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#ad2b6e77078a912cfaea9ebc45e876aea">rbegin</a> () const noexcept</td></tr>
<tr class="separator:ad2b6e77078a912cfaea9ebc45e876aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa37e8d6244ab4f608e00b619e14433a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#ac4cdc912734a2b6757cbb816ab2657ea">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#aa37e8d6244ab4f608e00b619e14433a5">rcbegin</a> () const noexcept</td></tr>
<tr class="separator:aa37e8d6244ab4f608e00b619e14433a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae499a978d0a0aec34cdc37ade4137aff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a850e708a94572268b80d79d8238c74fd">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#ae499a978d0a0aec34cdc37ade4137aff">rend</a> () noexcept</td></tr>
<tr class="separator:ae499a978d0a0aec34cdc37ade4137aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d74ddd51e82e4b632057b69935b116"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#ac4cdc912734a2b6757cbb816ab2657ea">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#aa0d74ddd51e82e4b632057b69935b116">rend</a> () const noexcept</td></tr>
<tr class="separator:aa0d74ddd51e82e4b632057b69935b116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bad2ff2e0a44fc871f8350b44a40e16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#ac4cdc912734a2b6757cbb816ab2657ea">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a4bad2ff2e0a44fc871f8350b44a40e16">rcend</a> () const noexcept</td></tr>
<tr class="separator:a4bad2ff2e0a44fc871f8350b44a40e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a023ea62fd39e755099542ff6dda50d1e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a023ea62fd39e755099542ff6dda50d1e">empty</a> () const noexcept</td></tr>
<tr class="separator:a023ea62fd39e755099542ff6dda50d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa37a53d11a5076aaeb33353028f4d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a1fa37a53d11a5076aaeb33353028f4d7">size</a> () const noexcept</td></tr>
<tr class="separator:a1fa37a53d11a5076aaeb33353028f4d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a7b4a8594e064e79b47fc6a502f436"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a32a7b4a8594e064e79b47fc6a502f436">max_size</a> () const noexcept</td></tr>
<tr class="separator:a32a7b4a8594e064e79b47fc6a502f436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbec08c6e8d45c108e5690bfffe12cd5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#acbec08c6e8d45c108e5690bfffe12cd5">clear</a> () noexcept</td></tr>
<tr class="separator:acbec08c6e8d45c108e5690bfffe12cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328a20c731b0e04d44d494c5f43ef8de"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a328a20c731b0e04d44d494c5f43ef8de">insert</a> (const <a class="el" href="classtsl_1_1ordered__set.html#aa3852aebb63dcde9d151859cb65f951e">value_type</a> &amp;value)</td></tr>
<tr class="separator:a328a20c731b0e04d44d494c5f43ef8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b6e9cf63b58ec83966f5d97661583d"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#aa7b6e9cf63b58ec83966f5d97661583d">insert</a> (<a class="el" href="classtsl_1_1ordered__set.html#aa3852aebb63dcde9d151859cb65f951e">value_type</a> &amp;&amp;value)</td></tr>
<tr class="separator:aa7b6e9cf63b58ec83966f5d97661583d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2459ce77751afca0043efcce1eb09cd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a2459ce77751afca0043efcce1eb09cd5">insert</a> (<a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a> hint, const <a class="el" href="classtsl_1_1ordered__set.html#aa3852aebb63dcde9d151859cb65f951e">value_type</a> &amp;value)</td></tr>
<tr class="separator:a2459ce77751afca0043efcce1eb09cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbba255e05528bca39a13ae86b5035c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#abbba255e05528bca39a13ae86b5035c6">insert</a> (<a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a> hint, <a class="el" href="classtsl_1_1ordered__set.html#aa3852aebb63dcde9d151859cb65f951e">value_type</a> &amp;&amp;value)</td></tr>
<tr class="separator:abbba255e05528bca39a13ae86b5035c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9621d330cbf43fec798bc63d191ed034"><td class="memTemplParams" colspan="2">template&lt;class InputIt &gt; </td></tr>
<tr class="memitem:a9621d330cbf43fec798bc63d191ed034"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a9621d330cbf43fec798bc63d191ed034">insert</a> (InputIt first, InputIt last)</td></tr>
<tr class="separator:a9621d330cbf43fec798bc63d191ed034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206421a6a18589f4bd7562c2db43d910"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a206421a6a18589f4bd7562c2db43d910">insert</a> (std::initializer_list&lt; <a class="el" href="classtsl_1_1ordered__set.html#aa3852aebb63dcde9d151859cb65f951e">value_type</a> &gt; ilist)</td></tr>
<tr class="separator:a206421a6a18589f4bd7562c2db43d910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a8ee2e57f3c30fe19b326a874f0bd5"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:ad4a8ee2e57f3c30fe19b326a874f0bd5"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#ad4a8ee2e57f3c30fe19b326a874f0bd5">emplace</a> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:ad4a8ee2e57f3c30fe19b326a874f0bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad266d5e2425b6af842790944fa75ef76"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:ad266d5e2425b6af842790944fa75ef76"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#ad266d5e2425b6af842790944fa75ef76">emplace_hint</a> (<a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a> hint, Args &amp;&amp;... args)</td></tr>
<tr class="separator:ad266d5e2425b6af842790944fa75ef76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91cb7fc84c0bfab1c196109d416bad85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a91cb7fc84c0bfab1c196109d416bad85">erase</a> (<a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a> pos)</td></tr>
<tr class="separator:a91cb7fc84c0bfab1c196109d416bad85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c3e96aba2834dcc28b22ee8699c914"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a05c3e96aba2834dcc28b22ee8699c914">erase</a> (<a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a> pos)</td></tr>
<tr class="separator:a05c3e96aba2834dcc28b22ee8699c914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318c0fb661e5e389f82bcb9f157db45d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a318c0fb661e5e389f82bcb9f157db45d">erase</a> (<a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a> first, <a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a> last)</td></tr>
<tr class="separator:a318c0fb661e5e389f82bcb9f157db45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a1e1054dd9e86fc0617070ad35f8d45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a4a1e1054dd9e86fc0617070ad35f8d45">erase</a> (const <a class="el" href="classtsl_1_1ordered__set.html#a02fb4e2e15f314f6ac35c214d9df23ef">key_type</a> &amp;key)</td></tr>
<tr class="separator:a4a1e1054dd9e86fc0617070ad35f8d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35895b2267b33386efdc0ccf2b262154"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a35895b2267b33386efdc0ccf2b262154">erase</a> (const <a class="el" href="classtsl_1_1ordered__set.html#a02fb4e2e15f314f6ac35c214d9df23ef">key_type</a> &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="separator:a35895b2267b33386efdc0ccf2b262154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc0464c0f492f1b411fcef7ac396936"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:aabc0464c0f492f1b411fcef7ac396936"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#aabc0464c0f492f1b411fcef7ac396936">erase</a> (const K &amp;key)</td></tr>
<tr class="separator:aabc0464c0f492f1b411fcef7ac396936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0e6377f984cd852e8861174fc28786"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a7e0e6377f984cd852e8861174fc28786"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a7e0e6377f984cd852e8861174fc28786">erase</a> (const K &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="separator:a7e0e6377f984cd852e8861174fc28786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2982b9af31dc0cfc8a9eccd9fe325fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#ac2982b9af31dc0cfc8a9eccd9fe325fc">swap</a> (<a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;other)</td></tr>
<tr class="separator:ac2982b9af31dc0cfc8a9eccd9fe325fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ec8f539f3a0dc869bd024bde891c8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#aa5ec8f539f3a0dc869bd024bde891c8a">count</a> (const Key &amp;key) const</td></tr>
<tr class="separator:aa5ec8f539f3a0dc869bd024bde891c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6671d647ef9402361c009af2f47e29ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a6671d647ef9402361c009af2f47e29ba">count</a> (const Key &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="separator:a6671d647ef9402361c009af2f47e29ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a766cac50caed1afe6b1dbb2c6447a55b"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a766cac50caed1afe6b1dbb2c6447a55b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a766cac50caed1afe6b1dbb2c6447a55b">count</a> (const K &amp;key) const</td></tr>
<tr class="separator:a766cac50caed1afe6b1dbb2c6447a55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced79117d7534ed3ab2d6a237a0058bc"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:aced79117d7534ed3ab2d6a237a0058bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#aced79117d7534ed3ab2d6a237a0058bc">count</a> (const K &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="separator:aced79117d7534ed3ab2d6a237a0058bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa1bbc404cc363153b6eb7d505448427"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#aaa1bbc404cc363153b6eb7d505448427">find</a> (const Key &amp;key)</td></tr>
<tr class="separator:aaa1bbc404cc363153b6eb7d505448427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe63aacec0b31672f70753f20c7e0d8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#abe63aacec0b31672f70753f20c7e0d8b">find</a> (const Key &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="separator:abe63aacec0b31672f70753f20c7e0d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49dd84b051493b6847f5ef7c7083d2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#ab49dd84b051493b6847f5ef7c7083d2b">find</a> (const Key &amp;key) const</td></tr>
<tr class="separator:ab49dd84b051493b6847f5ef7c7083d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef6331a007f7a8848b5dabc89238946"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#aaef6331a007f7a8848b5dabc89238946">find</a> (const Key &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="separator:aaef6331a007f7a8848b5dabc89238946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c6728c8839d9bfcec8785a3a918d33"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a46c6728c8839d9bfcec8785a3a918d33"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a46c6728c8839d9bfcec8785a3a918d33">find</a> (const K &amp;key)</td></tr>
<tr class="separator:a46c6728c8839d9bfcec8785a3a918d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced9be09be40ecc1b2b53148fdbeae3c"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:aced9be09be40ecc1b2b53148fdbeae3c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#aced9be09be40ecc1b2b53148fdbeae3c">find</a> (const K &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="separator:aced9be09be40ecc1b2b53148fdbeae3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f4eb260419db865a600bb927fde308"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a32f4eb260419db865a600bb927fde308"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a32f4eb260419db865a600bb927fde308">find</a> (const K &amp;key) const</td></tr>
<tr class="separator:a32f4eb260419db865a600bb927fde308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b56494c36c62b257971a5c89ce43ace"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a9b56494c36c62b257971a5c89ce43ace"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a9b56494c36c62b257971a5c89ce43ace">find</a> (const K &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="separator:a9b56494c36c62b257971a5c89ce43ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae442941c8eb016435f66dded57c1fbc8"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a>, <a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#ae442941c8eb016435f66dded57c1fbc8">equal_range</a> (const Key &amp;key)</td></tr>
<tr class="separator:ae442941c8eb016435f66dded57c1fbc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a3625f26abb12ef09c41e18a12bbef"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a>, <a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a75a3625f26abb12ef09c41e18a12bbef">equal_range</a> (const Key &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="separator:a75a3625f26abb12ef09c41e18a12bbef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ff69af2f016680ef22beb1d4e6c9a9"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a>, <a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#ae6ff69af2f016680ef22beb1d4e6c9a9">equal_range</a> (const Key &amp;key) const</td></tr>
<tr class="separator:ae6ff69af2f016680ef22beb1d4e6c9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c95b8ec1f1f4432b5b26ff5a83db5b0"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a>, <a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a3c95b8ec1f1f4432b5b26ff5a83db5b0">equal_range</a> (const Key &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="separator:a3c95b8ec1f1f4432b5b26ff5a83db5b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a2a9aca80e60c35f6a876f87015c335"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a5a2a9aca80e60c35f6a876f87015c335"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a>, <a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a5a2a9aca80e60c35f6a876f87015c335">equal_range</a> (const K &amp;key)</td></tr>
<tr class="separator:a5a2a9aca80e60c35f6a876f87015c335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80cd49bbc9a568fe78c14e7d80b81c9c"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a80cd49bbc9a568fe78c14e7d80b81c9c"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a>, <a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a80cd49bbc9a568fe78c14e7d80b81c9c">equal_range</a> (const K &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="separator:a80cd49bbc9a568fe78c14e7d80b81c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7f0385f77d78519f0eb6270cb70d62"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ada7f0385f77d78519f0eb6270cb70d62"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a>, <a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#ada7f0385f77d78519f0eb6270cb70d62">equal_range</a> (const K &amp;key) const</td></tr>
<tr class="separator:ada7f0385f77d78519f0eb6270cb70d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f8c028631f989a0ba04df9a6e66a04"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:aa6f8c028631f989a0ba04df9a6e66a04"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a>, <a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#aa6f8c028631f989a0ba04df9a6e66a04">equal_range</a> (const K &amp;key, std::size_t precalculated_hash) const</td></tr>
<tr class="separator:aa6f8c028631f989a0ba04df9a6e66a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9889c1abde8a4980dcedca11a4da90a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#ad9889c1abde8a4980dcedca11a4da90a">bucket_count</a> () const</td></tr>
<tr class="separator:ad9889c1abde8a4980dcedca11a4da90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbaddfe46e1e201edceb2f46d17cfafe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#adbaddfe46e1e201edceb2f46d17cfafe">max_bucket_count</a> () const</td></tr>
<tr class="separator:adbaddfe46e1e201edceb2f46d17cfafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7da7f251fd80a9091d334adcb5aeaede"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a7da7f251fd80a9091d334adcb5aeaede">load_factor</a> () const</td></tr>
<tr class="separator:a7da7f251fd80a9091d334adcb5aeaede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba63be49c8de3e2d799b2118bad8f71"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#adba63be49c8de3e2d799b2118bad8f71">max_load_factor</a> () const</td></tr>
<tr class="separator:adba63be49c8de3e2d799b2118bad8f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff78801e693da6fdbf73b617c16ec6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#abff78801e693da6fdbf73b617c16ec6e">max_load_factor</a> (float ml)</td></tr>
<tr class="separator:abff78801e693da6fdbf73b617c16ec6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc309424677397325af4476ac31e1500"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#acc309424677397325af4476ac31e1500">rehash</a> (<a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html#aa5ec8f539f3a0dc869bd024bde891c8a">count</a>)</td></tr>
<tr class="separator:acc309424677397325af4476ac31e1500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a62a8db59d69fb9b6f930c15427a0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#ab9a62a8db59d69fb9b6f930c15427a0e">reserve</a> (<a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html#aa5ec8f539f3a0dc869bd024bde891c8a">count</a>)</td></tr>
<tr class="separator:ab9a62a8db59d69fb9b6f930c15427a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7582155198c43ed0328394c589274a31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a5223d8468abce9948f98b3b95d1e982c">hasher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a7582155198c43ed0328394c589274a31">hash_function</a> () const</td></tr>
<tr class="separator:a7582155198c43ed0328394c589274a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5efaa0821707a99f0601f59015e719ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a13c68662e5e311f48f70ace69759342f">key_equal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a5efaa0821707a99f0601f59015e719ae">key_eq</a> () const</td></tr>
<tr class="separator:a5efaa0821707a99f0601f59015e719ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7866c9d599658f12dba6b17fed1b671d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a7866c9d599658f12dba6b17fed1b671d">mutable_iterator</a> (<a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a> pos)</td></tr>
<tr class="separator:a7866c9d599658f12dba6b17fed1b671d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4c67f752a07ced3348b0bc9a5afa3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#adc4c67f752a07ced3348b0bc9a5afa3a">nth</a> (<a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a> index)</td></tr>
<tr class="separator:adc4c67f752a07ced3348b0bc9a5afa3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2011ea9a10cc9f3e51fea95580abe1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#aba2011ea9a10cc9f3e51fea95580abe1">nth</a> (<a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a> index) const</td></tr>
<tr class="separator:aba2011ea9a10cc9f3e51fea95580abe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6601e0f32a8a36628753bfcbc096be0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a213465f357963c30b084451ad61299ac">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a6601e0f32a8a36628753bfcbc096be0f">front</a> () const</td></tr>
<tr class="separator:a6601e0f32a8a36628753bfcbc096be0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac182e91cae21e14dc0c2913779cf5368"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a213465f357963c30b084451ad61299ac">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#ac182e91cae21e14dc0c2913779cf5368">back</a> () const</td></tr>
<tr class="separator:ac182e91cae21e14dc0c2913779cf5368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec9980b152c71a875fc4a4e1d7bb78c"><td class="memTemplParams" colspan="2">template&lt;class U  = values_container_type, typename std::enable_if&lt; tsl::detail_ordered_hash::is_vector&lt; U &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a3ec9980b152c71a875fc4a4e1d7bb78c"><td class="memTemplItemLeft" align="right" valign="top">const values_container_type::value_type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a3ec9980b152c71a875fc4a4e1d7bb78c">data</a> () const noexcept</td></tr>
<tr class="separator:a3ec9980b152c71a875fc4a4e1d7bb78c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc951514a5c4c29c14b6cf5177cf1ec"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtsl_1_1ordered__set.html#af68942b7edb65da7c0ec756b7172f497">values_container_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a1bc951514a5c4c29c14b6cf5177cf1ec">values_container</a> () const noexcept</td></tr>
<tr class="separator:a1bc951514a5c4c29c14b6cf5177cf1ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6182f68f6d191ba2c957daea2fbe32dc"><td class="memTemplParams" colspan="2">template&lt;class U  = values_container_type, typename std::enable_if&lt; tsl::detail_ordered_hash::is_vector&lt; U &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a6182f68f6d191ba2c957daea2fbe32dc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a6182f68f6d191ba2c957daea2fbe32dc">capacity</a> () const noexcept</td></tr>
<tr class="separator:a6182f68f6d191ba2c957daea2fbe32dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f1cb2ec551059e1316532205c461a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#ad3f1cb2ec551059e1316532205c461a7">shrink_to_fit</a> ()</td></tr>
<tr class="separator:ad3f1cb2ec551059e1316532205c461a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03dd4f519aaaa11716a3eb3a7132446"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#af03dd4f519aaaa11716a3eb3a7132446">insert_at_position</a> (<a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a> pos, const <a class="el" href="classtsl_1_1ordered__set.html#aa3852aebb63dcde9d151859cb65f951e">value_type</a> &amp;value)</td></tr>
<tr class="separator:af03dd4f519aaaa11716a3eb3a7132446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae9f958a17a59a693569a0519685fc0a"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#aae9f958a17a59a693569a0519685fc0a">insert_at_position</a> (<a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a> pos, <a class="el" href="classtsl_1_1ordered__set.html#aa3852aebb63dcde9d151859cb65f951e">value_type</a> &amp;&amp;value)</td></tr>
<tr class="separator:aae9f958a17a59a693569a0519685fc0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227c222d9754fccd991600f109b86aea"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a227c222d9754fccd991600f109b86aea"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a227c222d9754fccd991600f109b86aea">emplace_at_position</a> (<a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a> pos, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a227c222d9754fccd991600f109b86aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae440c07d0c3401bb8a1e672cda9d39d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#ae440c07d0c3401bb8a1e672cda9d39d8">pop_back</a> ()</td></tr>
<tr class="separator:ae440c07d0c3401bb8a1e672cda9d39d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96fc16543a99e892512b9119375c0fe5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a96fc16543a99e892512b9119375c0fe5">unordered_erase</a> (<a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a> pos)</td></tr>
<tr class="separator:a96fc16543a99e892512b9119375c0fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0e19fd5e5e8832c522b6f876d2a7f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a4c0e19fd5e5e8832c522b6f876d2a7f9">unordered_erase</a> (<a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a> pos)</td></tr>
<tr class="separator:a4c0e19fd5e5e8832c522b6f876d2a7f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89a8c07da6b74f3dd737a77366d49cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#ae89a8c07da6b74f3dd737a77366d49cf">unordered_erase</a> (const <a class="el" href="classtsl_1_1ordered__set.html#a02fb4e2e15f314f6ac35c214d9df23ef">key_type</a> &amp;key)</td></tr>
<tr class="separator:ae89a8c07da6b74f3dd737a77366d49cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b291ce4c12967996a10646ded0d352c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a9b291ce4c12967996a10646ded0d352c">unordered_erase</a> (const <a class="el" href="classtsl_1_1ordered__set.html#a02fb4e2e15f314f6ac35c214d9df23ef">key_type</a> &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="separator:a9b291ce4c12967996a10646ded0d352c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b30fbcf395a674198bc7943bb04d756"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a2b30fbcf395a674198bc7943bb04d756"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a2b30fbcf395a674198bc7943bb04d756">unordered_erase</a> (const K &amp;key)</td></tr>
<tr class="separator:a2b30fbcf395a674198bc7943bb04d756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a979b730573d4d61fd42df217b8bccd20"><td class="memTemplParams" colspan="2">template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a979b730573d4d61fd42df217b8bccd20"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a979b730573d4d61fd42df217b8bccd20">unordered_erase</a> (const K &amp;key, std::size_t precalculated_hash)</td></tr>
<tr class="separator:a979b730573d4d61fd42df217b8bccd20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a50408f6297bc6ecb05c7a0942bb581"><td class="memTemplParams" colspan="2">template&lt;class Serializer &gt; </td></tr>
<tr class="memitem:a6a50408f6297bc6ecb05c7a0942bb581"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a6a50408f6297bc6ecb05c7a0942bb581">serialize</a> (Serializer &amp;serializer) const</td></tr>
<tr class="separator:a6a50408f6297bc6ecb05c7a0942bb581"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aaf995efb5c45de92a8ef1d35f6e7e28e"><td class="memTemplParams" colspan="2">template&lt;class Deserializer &gt; </td></tr>
<tr class="memitem:aaf995efb5c45de92a8ef1d35f6e7e28e"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#aaf995efb5c45de92a8ef1d35f6e7e28e">deserialize</a> (Deserializer &amp;deserializer, bool hash_compatible=false)</td></tr>
<tr class="separator:aaf995efb5c45de92a8ef1d35f6e7e28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aa58b43c0c001cea18c9b7d7714b9d85c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#aa58b43c0c001cea18c9b7d7714b9d85c">operator==</a> (const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;lhs, const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;rhs)</td></tr>
<tr class="separator:aa58b43c0c001cea18c9b7d7714b9d85c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafca13b71af5e35082b3e22c01680844"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#aafca13b71af5e35082b3e22c01680844">operator!=</a> (const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;lhs, const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;rhs)</td></tr>
<tr class="separator:aafca13b71af5e35082b3e22c01680844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad685a66cbb7c59a0923ca7d57a734c27"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#ad685a66cbb7c59a0923ca7d57a734c27">operator&lt;</a> (const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;lhs, const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;rhs)</td></tr>
<tr class="separator:ad685a66cbb7c59a0923ca7d57a734c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506164f732a96dfefef194dd47c5459d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a506164f732a96dfefef194dd47c5459d">operator&lt;=</a> (const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;lhs, const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;rhs)</td></tr>
<tr class="separator:a506164f732a96dfefef194dd47c5459d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59796ffdc4400bdcb82073c952cdf451"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a59796ffdc4400bdcb82073c952cdf451">operator&gt;</a> (const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;lhs, const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;rhs)</td></tr>
<tr class="separator:a59796ffdc4400bdcb82073c952cdf451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a17aeb7a1827b4f3cc26552ddb9db0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a94a17aeb7a1827b4f3cc26552ddb9db0">operator&gt;=</a> (const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;lhs, const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;rhs)</td></tr>
<tr class="separator:a94a17aeb7a1827b4f3cc26552ddb9db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb2c2dd5207da0a8b606fc11fa6dba8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtsl_1_1ordered__set.html#a5fb2c2dd5207da0a8b606fc11fa6dba8">swap</a> (<a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;lhs, <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> &amp;rhs)</td></tr>
<tr class="separator:a5fb2c2dd5207da0a8b606fc11fa6dba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Key, class Hash = std::hash&lt;Key&gt;, class KeyEqual = std::equal_to&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;, class ValueTypeContainer = std::deque&lt;Key, Allocator&gt;, class IndexType = std::uint_least32_t&gt;<br />
class tsl::ordered_set&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;</h3>

<p>Implementation of an hash set using open adressing with robin hood with backshift delete to resolve collisions.</p>
<p>The particularity of this hash set is that it remembers the order in which the elements were added and provide a way to access the structure which stores these values through the '<a class="el" href="classtsl_1_1ordered__set.html#a1bc951514a5c4c29c14b6cf5177cf1ec">values_container()</a>' method. The used container is defined by ValueTypeContainer, by default a std::deque is used (grows faster) but a std::vector may be used. In this case the set provides a '<a class="el" href="classtsl_1_1ordered__set.html#a3ec9980b152c71a875fc4a4e1d7bb78c">data()</a>' method which give a direct access to the memory used to store the values (which can be usefull to communicate with C API's).</p>
<p>The Key must be copy constructible and/or move constructible. To use <code>unordered_erase</code> it also must be swappable.</p>
<p>The behaviour of the hash set is undefinded if the destructor of Key throws an exception.</p>
<p>By default the maximum size of a set is limited to 2^32 - 1 values, if needed this can be changed through the IndexType template parameter. Using an <code>uint64_t</code> will raise this limit to 2^64 - 1 values but each bucket will use 16 bytes instead of 8 bytes in addition to the space needed to store the values.</p>
<p>Iterators invalidation:</p><ul>
<li>clear, operator=, reserve, rehash: always invalidate the iterators (also invalidate <a class="el" href="classtsl_1_1ordered__set.html#a5aa697b0fafb7028551f4d4f66381ca8">end()</a>).</li>
<li>insert, emplace, emplace_hint, operator[]: when a std::vector is used as ValueTypeContainer and if <a class="el" href="classtsl_1_1ordered__set.html#a1fa37a53d11a5076aaeb33353028f4d7">size()</a> &lt; <a class="el" href="classtsl_1_1ordered__set.html#a6182f68f6d191ba2c957daea2fbe32dc">capacity()</a>, only <a class="el" href="classtsl_1_1ordered__set.html#a5aa697b0fafb7028551f4d4f66381ca8">end()</a>. Otherwise all the iterators are invalidated if an insert occurs.</li>
<li>erase, unordered_erase: when a std::vector is used as ValueTypeContainer invalidate the iterator of the erased element and all the ones after the erased element (including <a class="el" href="classtsl_1_1ordered__set.html#a5aa697b0fafb7028551f4d4f66381ca8">end()</a>). Otherwise all the iterators are invalidated if an erase occurs. </li>
</ul>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a8fbfaf193b1d445d0947dfc5678b6855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fbfaf193b1d445d0947dfc5678b6855">&#9670;&nbsp;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::<a class="el" href="classtsl_1_1ordered__set.html#a8fbfaf193b1d445d0947dfc5678b6855">allocator_type</a> =  typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#ab11ec82b2c02993170fa5645797bf6f5">ht::allocator_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3a1996923ed0d9b62d7d959af57a1be3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a1996923ed0d9b62d7d959af57a1be3">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::<a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a> =  typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#a6dbac93fb19be2c2e929489fb0b5c385">ht::const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3bd3a5ea8376cdc30c81eb93283b352b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bd3a5ea8376cdc30c81eb93283b352b">&#9670;&nbsp;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::<a class="el" href="classtsl_1_1ordered__set.html#a3bd3a5ea8376cdc30c81eb93283b352b">const_pointer</a> =  typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#a584cb2f4d6e7e7e8e1356a31677f24ec">ht::const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a213465f357963c30b084451ad61299ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a213465f357963c30b084451ad61299ac">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::<a class="el" href="classtsl_1_1ordered__set.html#a213465f357963c30b084451ad61299ac">const_reference</a> =  typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#a3ef2c7c6e46c43ce02aed27f44c30452">ht::const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac4cdc912734a2b6757cbb816ab2657ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4cdc912734a2b6757cbb816ab2657ea">&#9670;&nbsp;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::<a class="el" href="classtsl_1_1ordered__set.html#ac4cdc912734a2b6757cbb816ab2657ea">const_reverse_iterator</a> =  typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#a2f2940b46a61dc1af261e2a40904a7b0">ht::const_reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a74aabf02f8feedcae29dc7486d764a9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74aabf02f8feedcae29dc7486d764a9b">&#9670;&nbsp;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::<a class="el" href="classtsl_1_1ordered__set.html#a74aabf02f8feedcae29dc7486d764a9b">difference_type</a> =  typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#af2a6592e3f27b098824e1c3ae2b7c80f">ht::difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5223d8468abce9948f98b3b95d1e982c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5223d8468abce9948f98b3b95d1e982c">&#9670;&nbsp;</a></span>hasher</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::<a class="el" href="classtsl_1_1ordered__set.html#a5223d8468abce9948f98b3b95d1e982c">hasher</a> =  typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#aec06904df31ad580930684637da4a733">ht::hasher</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6b02aa2270e720edf5b8a30b106e7346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b02aa2270e720edf5b8a30b106e7346">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::<a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a> =  typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#a67c369d7edd1131bf9e0a8ada4e4d094">ht::iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a13c68662e5e311f48f70ace69759342f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c68662e5e311f48f70ace69759342f">&#9670;&nbsp;</a></span>key_equal</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::<a class="el" href="classtsl_1_1ordered__set.html#a13c68662e5e311f48f70ace69759342f">key_equal</a> =  typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#a61a5c29ff6c4378ad1efba76b26228cb">ht::key_equal</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a02fb4e2e15f314f6ac35c214d9df23ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02fb4e2e15f314f6ac35c214d9df23ef">&#9670;&nbsp;</a></span>key_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::<a class="el" href="classtsl_1_1ordered__set.html#a02fb4e2e15f314f6ac35c214d9df23ef">key_type</a> =  typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#aa14641f4be3e4aca317b1cb0a8bbded4">ht::key_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a274eb7795de5ce31fa932e97ccb255cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a274eb7795de5ce31fa932e97ccb255cb">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::<a class="el" href="classtsl_1_1ordered__set.html#a274eb7795de5ce31fa932e97ccb255cb">pointer</a> =  typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#ac4e053f630b968f7bf8d21bc00aed068">ht::pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a958a0120052bda326fb7bf72e9878a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a958a0120052bda326fb7bf72e9878a5c">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::<a class="el" href="classtsl_1_1ordered__set.html#a958a0120052bda326fb7bf72e9878a5c">reference</a> =  typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#af89a4de3e6c41488b2b29fbeea4682db">ht::reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a850e708a94572268b80d79d8238c74fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a850e708a94572268b80d79d8238c74fd">&#9670;&nbsp;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::<a class="el" href="classtsl_1_1ordered__set.html#a850e708a94572268b80d79d8238c74fd">reverse_iterator</a> =  typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#aa7801013d5f330513e4d9743b40f8cf1">ht::reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2679e2e7b1ac5583afe30254f3fe2391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2679e2e7b1ac5583afe30254f3fe2391">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::<a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a> =  typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#a77c1ebd8a153b092abd1513aeed8b838">ht::size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa3852aebb63dcde9d151859cb65f951e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3852aebb63dcde9d151859cb65f951e">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::<a class="el" href="classtsl_1_1ordered__set.html#aa3852aebb63dcde9d151859cb65f951e">value_type</a> =  typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#a675a898ce63c4df6ea9ab7db1a8ffa7a">ht::value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af68942b7edb65da7c0ec756b7172f497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af68942b7edb65da7c0ec756b7172f497">&#9670;&nbsp;</a></span>values_container_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::<a class="el" href="classtsl_1_1ordered__set.html#af68942b7edb65da7c0ec756b7172f497">values_container_type</a> =  typename <a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#ad907d82adf51d0502fe818a7131a0936">ht::values_container_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a700b6bf2da365f1e04c1d35190567024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a700b6bf2da365f1e04c1d35190567024">&#9670;&nbsp;</a></span>ordered_set() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::<a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ec2418fd9c2d4ee6ee02f7b4fa0caa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ec2418fd9c2d4ee6ee02f7b4fa0caa1">&#9670;&nbsp;</a></span>ordered_set() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::<a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em> = <code>Hash()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyEqual &amp;&#160;</td>
          <td class="paramname"><em>equal</em> = <code>KeyEqual()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0a2c776d606ff253b16ded3ebc50f081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a2c776d606ff253b16ded3ebc50f081">&#9670;&nbsp;</a></span>ordered_set() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::<a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab684dbea1303cf3173ea839eee34fd44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab684dbea1303cf3173ea839eee34fd44">&#9670;&nbsp;</a></span>ordered_set() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::<a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a721a7fcbb629b9c000c2e77925b4fa36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a721a7fcbb629b9c000c2e77925b4fa36">&#9670;&nbsp;</a></span>ordered_set() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::<a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> </td>
          <td>(</td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aad057518e7311f0437ec1f7b059525bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad057518e7311f0437ec1f7b059525bd">&#9670;&nbsp;</a></span>ordered_set() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::<a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em> = <code><a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#abef368126aac0177fcf90d85c63eedef">ht::DEFAULT_INIT_BUCKETS_SIZE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em> = <code>Hash()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyEqual &amp;&#160;</td>
          <td class="paramname"><em>equal</em> = <code>KeyEqual()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1925811490371805e060c1488063a545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1925811490371805e060c1488063a545">&#9670;&nbsp;</a></span>ordered_set() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::<a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a040a736e5534ba4a3c0467779df0b26b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a040a736e5534ba4a3c0467779df0b26b">&#9670;&nbsp;</a></span>ordered_set() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::<a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af15847bafa2827f9558ff3113ce3c047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af15847bafa2827f9558ff3113ce3c047">&#9670;&nbsp;</a></span>ordered_set() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::<a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classtsl_1_1ordered__set.html#aa3852aebb63dcde9d151859cb65f951e">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em> = <code><a class="el" href="classtsl_1_1detail__ordered__hash_1_1ordered__hash.html#abef368126aac0177fcf90d85c63eedef">ht::DEFAULT_INIT_BUCKETS_SIZE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em> = <code>Hash()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyEqual &amp;&#160;</td>
          <td class="paramname"><em>equal</em> = <code>KeyEqual()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3756674af513e07365ea58a4307ea068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3756674af513e07365ea58a4307ea068">&#9670;&nbsp;</a></span>ordered_set() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::<a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classtsl_1_1ordered__set.html#aa3852aebb63dcde9d151859cb65f951e">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ada7c8348ee664b0c8d51c241ce3c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ada7c8348ee664b0c8d51c241ce3c82">&#9670;&nbsp;</a></span>ordered_set() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::<a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classtsl_1_1ordered__set.html#aa3852aebb63dcde9d151859cb65f951e">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a>&#160;</td>
          <td class="paramname"><em>bucket_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hash &amp;&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac182e91cae21e14dc0c2913779cf5368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac182e91cae21e14dc0c2913779cf5368">&#9670;&nbsp;</a></span>back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a213465f357963c30b084451ad61299ac">const_reference</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return const_reference to the last element. Requires the container to not be empty. </p>

</div>
</div>
<a id="a13854981a0a6dcf3caa8681249c8a2a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13854981a0a6dcf3caa8681249c8a2a6">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8bcc4e4dd0290e5e95ac5581a90877d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bcc4e4dd0290e5e95ac5581a90877d7">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad9889c1abde8a4980dcedca11a4da90a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9889c1abde8a4980dcedca11a4da90a">&#9670;&nbsp;</a></span>bucket_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6182f68f6d191ba2c957daea2fbe32dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6182f68f6d191ba2c957daea2fbe32dc">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<div class="memtemplate">
template&lt;class U  = values_container_type, typename std::enable_if&lt; tsl::detail_ordered_hash::is_vector&lt; U &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a10355d72c3d4c1ab5c3995612239f40f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10355d72c3d4c1ab5c3995612239f40f">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a54476254fe316471d65ff77a73941fb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54476254fe316471d65ff77a73941fb5">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acbec08c6e8d45c108e5690bfffe12cd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbec08c6e8d45c108e5690bfffe12cd5">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa5ec8f539f3a0dc869bd024bde891c8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5ec8f539f3a0dc869bd024bde891c8a">&#9670;&nbsp;</a></span>count() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6671d647ef9402361c009af2f47e29ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6671d647ef9402361c009af2f47e29ba">&#9670;&nbsp;</a></span>count() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1ordered__set.html#a7582155198c43ed0328394c589274a31">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a766cac50caed1afe6b1dbb2c6447a55b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a766cac50caed1afe6b1dbb2c6447a55b">&#9670;&nbsp;</a></span>count() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="aced79117d7534ed3ab2d6a237a0058bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aced79117d7534ed3ab2d6a237a0058bc">&#9670;&nbsp;</a></span>count() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key.</p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1ordered__set.html#a7582155198c43ed0328394c589274a31">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a3ec9980b152c71a875fc4a4e1d7bb78c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ec9980b152c71a875fc4a4e1d7bb78c">&#9670;&nbsp;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<div class="memtemplate">
template&lt;class U  = values_container_type, typename std::enable_if&lt; tsl::detail_ordered_hash::is_vector&lt; U &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const values_container_type::value_type* <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Only available if ValueTypeContainer is a std::vector. Same as calling '<a class="el" href="classtsl_1_1ordered__set.html#a1bc951514a5c4c29c14b6cf5177cf1ec">values_container()</a>.<a class="el" href="classtsl_1_1ordered__set.html#a3ec9980b152c71a875fc4a4e1d7bb78c">data()</a>'. </p>

</div>
</div>
<a id="aaf995efb5c45de92a8ef1d35f6e7e28e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf995efb5c45de92a8ef1d35f6e7e28e">&#9670;&nbsp;</a></span>deserialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<div class="memtemplate">
template&lt;class Deserializer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::deserialize </td>
          <td>(</td>
          <td class="paramtype">Deserializer &amp;&#160;</td>
          <td class="paramname"><em>deserializer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hash_compatible</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deserialize a previouly serialized set through the <code>deserializer</code> parameter.</p>
<p>The <code>deserializer</code> parameter must be a function object that supports the following calls:</p><ul>
<li><code>template&lt;typename U&gt; U operator()();</code> where the types <code>std::uint64_t</code>, <code>float</code> and <code>Key</code> must be supported for U.</li>
</ul>
<p>If the deserialized hash set type is hash compatible with the serialized set, the deserialization process can be sped up by setting <code>hash_compatible</code> to true. To be hash compatible, the Hash and KeyEqual must behave the same way than the ones used on the serialized map. The <code>std::size_t</code> must also be of the same size as the one on the platform used to serialize the map, the same apply for <code>IndexType</code>. If these criteria are not met, the behaviour is undefined with <code>hash_compatible</code> sets to true.</p>
<p>The behaviour is undefined if the type <code>Key</code> of the <code><a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a></code> is not the same as the type used during serialization.</p>
<p>The implementation leaves binary compatibilty (endianness, IEEE 754 for floats, size of int, ...) of the types it deserializes in the hands of the <code>Deserializer</code> function object if compatibilty is required. </p>

</div>
</div>
<a id="ad4a8ee2e57f3c30fe19b326a874f0bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4a8ee2e57f3c30fe19b326a874f0bd5">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a>, bool&gt; <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Due to the way elements are stored, emplace will need to move or copy the key-value once. The method is equivalent to insert(value_type(std::forward&lt;Args&gt;(args)...));</p>
<p>Mainly here for compatibility with the std::unordered_map interface. </p>

</div>
</div>
<a id="a227c222d9754fccd991600f109b86aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227c222d9754fccd991600f109b86aea">&#9670;&nbsp;</a></span>emplace_at_position()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a>, bool&gt; <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::emplace_at_position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Insert the value before pos shifting all the elements on the right of pos (including pos) one position to the right.</p>
<p>Amortized linear time-complexity in the distance between pos and <a class="el" href="classtsl_1_1ordered__set.html#a5aa697b0fafb7028551f4d4f66381ca8">end()</a>.</p>
<p>Same as insert_at_position(pos, value_type(std::forward&lt;Args&gt;(args)...), mainly here for coherence. </p>

</div>
</div>
<a id="ad266d5e2425b6af842790944fa75ef76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad266d5e2425b6af842790944fa75ef76">&#9670;&nbsp;</a></span>emplace_hint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::emplace_hint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Due to the way elements are stored, emplace_hint will need to move or copy the key-value once. The method is equivalent to insert(hint, value_type(std::forward&lt;Args&gt;(args)...));</p>
<p>Mainly here for compatibility with the std::unordered_map interface. </p>

</div>
</div>
<a id="a023ea62fd39e755099542ff6dda50d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a023ea62fd39e755099542ff6dda50d1e">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5aa697b0fafb7028551f4d4f66381ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aa697b0fafb7028551f4d4f66381ca8">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa2eb040a0129c07e9735448b114ab5e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2eb040a0129c07e9735448b114ab5e8">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae442941c8eb016435f66dded57c1fbc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae442941c8eb016435f66dded57c1fbc8">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a>, <a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a>&gt; <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a75a3625f26abb12ef09c41e18a12bbef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75a3625f26abb12ef09c41e18a12bbef">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a>, <a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a>&gt; <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1ordered__set.html#a7582155198c43ed0328394c589274a31">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="ae6ff69af2f016680ef22beb1d4e6c9a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6ff69af2f016680ef22beb1d4e6c9a9">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a>, <a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a>&gt; <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c95b8ec1f1f4432b5b26ff5a83db5b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c95b8ec1f1f4432b5b26ff5a83db5b0">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a>, <a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a>&gt; <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1ordered__set.html#a7582155198c43ed0328394c589274a31">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a5a2a9aca80e60c35f6a876f87015c335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a2a9aca80e60c35f6a876f87015c335">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a>, <a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a>&gt; <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="a80cd49bbc9a568fe78c14e7d80b81c9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80cd49bbc9a568fe78c14e7d80b81c9c">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a>, <a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a>&gt; <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key.</p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1ordered__set.html#a7582155198c43ed0328394c589274a31">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="ada7f0385f77d78519f0eb6270cb70d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada7f0385f77d78519f0eb6270cb70d62">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a>, <a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a>&gt; <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="aa6f8c028631f989a0ba04df9a6e66a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6f8c028631f989a0ba04df9a6e66a04">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a>, <a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a>&gt; <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key.</p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1ordered__set.html#a7582155198c43ed0328394c589274a31">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a91cb7fc84c0bfab1c196109d416bad85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91cb7fc84c0bfab1c196109d416bad85">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When erasing an element, the insert order will be preserved and no holes will be present in the container returned by '<a class="el" href="classtsl_1_1ordered__set.html#a1bc951514a5c4c29c14b6cf5177cf1ec">values_container()</a>'.</p>
<p>The method is in O(n), if the order is not important 'unordered_erase(...)' method is faster with an O(1) average complexity. </p>

</div>
</div>
<a id="a05c3e96aba2834dcc28b22ee8699c914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05c3e96aba2834dcc28b22ee8699c914">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>When erasing an element, the insert order will be preserved and no holes will be present in the container returned by '<a class="el" href="classtsl_1_1ordered__set.html#a1bc951514a5c4c29c14b6cf5177cf1ec">values_container()</a>'.</p>
<p>The method is in O(n), if the order is not important 'unordered_erase(...)' method is faster with an O(1) average complexity. </p>

</div>
</div>
<a id="a318c0fb661e5e389f82bcb9f157db45d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a318c0fb661e5e389f82bcb9f157db45d">&#9670;&nbsp;</a></span>erase() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>When erasing an element, the insert order will be preserved and no holes will be present in the container returned by '<a class="el" href="classtsl_1_1ordered__set.html#a1bc951514a5c4c29c14b6cf5177cf1ec">values_container()</a>'.</p>
<p>The method is in O(n), if the order is not important 'unordered_erase(...)' method is faster with an O(1) average complexity. </p>

</div>
</div>
<a id="a4a1e1054dd9e86fc0617070ad35f8d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a1e1054dd9e86fc0617070ad35f8d45">&#9670;&nbsp;</a></span>erase() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1ordered__set.html#a02fb4e2e15f314f6ac35c214d9df23ef">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>When erasing an element, the insert order will be preserved and no holes will be present in the container returned by '<a class="el" href="classtsl_1_1ordered__set.html#a1bc951514a5c4c29c14b6cf5177cf1ec">values_container()</a>'.</p>
<p>The method is in O(n), if the order is not important 'unordered_erase(...)' method is faster with an O(1) average complexity. </p>

</div>
</div>
<a id="a35895b2267b33386efdc0ccf2b262154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35895b2267b33386efdc0ccf2b262154">&#9670;&nbsp;</a></span>erase() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1ordered__set.html#a02fb4e2e15f314f6ac35c214d9df23ef">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>When erasing an element, the insert order will be preserved and no holes will be present in the container returned by '<a class="el" href="classtsl_1_1ordered__set.html#a1bc951514a5c4c29c14b6cf5177cf1ec">values_container()</a>'.</p>
<p>The method is in O(n), if the order is not important 'unordered_erase(...)' method is faster with an O(1) average complexity.</p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1ordered__set.html#a7582155198c43ed0328394c589274a31">hash_function()</a>(key). Usefull to speed-up the lookup to the value if you already have the hash. </p>

</div>
</div>
<a id="aabc0464c0f492f1b411fcef7ac396936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabc0464c0f492f1b411fcef7ac396936">&#9670;&nbsp;</a></span>erase() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>When erasing an element, the insert order will be preserved and no holes will be present in the container returned by '<a class="el" href="classtsl_1_1ordered__set.html#a1bc951514a5c4c29c14b6cf5177cf1ec">values_container()</a>'.</p>
<p>The method is in O(n), if the order is not important 'unordered_erase(...)' method is faster with an O(1) average complexity.</p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="a7e0e6377f984cd852e8861174fc28786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e0e6377f984cd852e8861174fc28786">&#9670;&nbsp;</a></span>erase() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>When erasing an element, the insert order will be preserved and no holes will be present in the container returned by '<a class="el" href="classtsl_1_1ordered__set.html#a1bc951514a5c4c29c14b6cf5177cf1ec">values_container()</a>'.</p>
<p>The method is in O(n), if the order is not important 'unordered_erase(...)' method is faster with an O(1) average complexity.</p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1ordered__set.html#a7582155198c43ed0328394c589274a31">hash_function()</a>(key). Usefull to speed-up the lookup to the value if you already have the hash.</p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="aaa1bbc404cc363153b6eb7d505448427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa1bbc404cc363153b6eb7d505448427">&#9670;&nbsp;</a></span>find() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abe63aacec0b31672f70753f20c7e0d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe63aacec0b31672f70753f20c7e0d8b">&#9670;&nbsp;</a></span>find() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1ordered__set.html#a7582155198c43ed0328394c589274a31">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="ab49dd84b051493b6847f5ef7c7083d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab49dd84b051493b6847f5ef7c7083d2b">&#9670;&nbsp;</a></span>find() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaef6331a007f7a8848b5dabc89238946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaef6331a007f7a8848b5dabc89238946">&#9670;&nbsp;</a></span>find() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1ordered__set.html#a7582155198c43ed0328394c589274a31">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a46c6728c8839d9bfcec8785a3a918d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46c6728c8839d9bfcec8785a3a918d33">&#9670;&nbsp;</a></span>find() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="aced9be09be40ecc1b2b53148fdbeae3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aced9be09be40ecc1b2b53148fdbeae3c">&#9670;&nbsp;</a></span>find() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key.</p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1ordered__set.html#a7582155198c43ed0328394c589274a31">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a32f4eb260419db865a600bb927fde308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32f4eb260419db865a600bb927fde308">&#9670;&nbsp;</a></span>find() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="a9b56494c36c62b257971a5c89ce43ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b56494c36c62b257971a5c89ce43ace">&#9670;&nbsp;</a></span>find() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key.</p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1ordered__set.html#a7582155198c43ed0328394c589274a31">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a6601e0f32a8a36628753bfcbc096be0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6601e0f32a8a36628753bfcbc096be0f">&#9670;&nbsp;</a></span>front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a213465f357963c30b084451ad61299ac">const_reference</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return const_reference to the first element. Requires the container to not be empty. </p>

</div>
</div>
<a id="a43ee92e0575ea5eda52000fa7359e19a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43ee92e0575ea5eda52000fa7359e19a">&#9670;&nbsp;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a8fbfaf193b1d445d0947dfc5678b6855">allocator_type</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7582155198c43ed0328394c589274a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7582155198c43ed0328394c589274a31">&#9670;&nbsp;</a></span>hash_function()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a5223d8468abce9948f98b3b95d1e982c">hasher</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::hash_function </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a328a20c731b0e04d44d494c5f43ef8de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a328a20c731b0e04d44d494c5f43ef8de">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a>, bool&gt; <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1ordered__set.html#aa3852aebb63dcde9d151859cb65f951e">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa7b6e9cf63b58ec83966f5d97661583d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7b6e9cf63b58ec83966f5d97661583d">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a>, bool&gt; <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#aa3852aebb63dcde9d151859cb65f951e">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2459ce77751afca0043efcce1eb09cd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2459ce77751afca0043efcce1eb09cd5">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1ordered__set.html#aa3852aebb63dcde9d151859cb65f951e">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abbba255e05528bca39a13ae86b5035c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbba255e05528bca39a13ae86b5035c6">&#9670;&nbsp;</a></span>insert() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#aa3852aebb63dcde9d151859cb65f951e">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9621d330cbf43fec798bc63d191ed034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9621d330cbf43fec798bc63d191ed034">&#9670;&nbsp;</a></span>insert() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<div class="memtemplate">
template&lt;class InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a206421a6a18589f4bd7562c2db43d910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a206421a6a18589f4bd7562c2db43d910">&#9670;&nbsp;</a></span>insert() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classtsl_1_1ordered__set.html#aa3852aebb63dcde9d151859cb65f951e">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af03dd4f519aaaa11716a3eb3a7132446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af03dd4f519aaaa11716a3eb3a7132446">&#9670;&nbsp;</a></span>insert_at_position() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a>, bool&gt; <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::insert_at_position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1ordered__set.html#aa3852aebb63dcde9d151859cb65f951e">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Insert the value before pos shifting all the elements on the right of pos (including pos) one position to the right.</p>
<p>Amortized linear time-complexity in the distance between pos and <a class="el" href="classtsl_1_1ordered__set.html#a5aa697b0fafb7028551f4d4f66381ca8">end()</a>. </p>

</div>
</div>
<a id="aae9f958a17a59a693569a0519685fc0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae9f958a17a59a693569a0519685fc0a">&#9670;&nbsp;</a></span>insert_at_position() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a>, bool&gt; <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::insert_at_position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#aa3852aebb63dcde9d151859cb65f951e">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Insert the value before pos shifting all the elements on the right of pos (including pos) one position to the right.</p>
<p>Amortized linear time-complexity in the distance between pos and <a class="el" href="classtsl_1_1ordered__set.html#a5aa697b0fafb7028551f4d4f66381ca8">end()</a>. </p>

</div>
</div>
<a id="a5efaa0821707a99f0601f59015e719ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5efaa0821707a99f0601f59015e719ae">&#9670;&nbsp;</a></span>key_eq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a13c68662e5e311f48f70ace69759342f">key_equal</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::key_eq </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7da7f251fd80a9091d334adcb5aeaede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7da7f251fd80a9091d334adcb5aeaede">&#9670;&nbsp;</a></span>load_factor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::load_factor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adbaddfe46e1e201edceb2f46d17cfafe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbaddfe46e1e201edceb2f46d17cfafe">&#9670;&nbsp;</a></span>max_bucket_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::max_bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adba63be49c8de3e2d799b2118bad8f71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adba63be49c8de3e2d799b2118bad8f71">&#9670;&nbsp;</a></span>max_load_factor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::max_load_factor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abff78801e693da6fdbf73b617c16ec6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff78801e693da6fdbf73b617c16ec6e">&#9670;&nbsp;</a></span>max_load_factor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::max_load_factor </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ml</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a32a7b4a8594e064e79b47fc6a502f436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32a7b4a8594e064e79b47fc6a502f436">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7866c9d599658f12dba6b17fed1b671d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7866c9d599658f12dba6b17fed1b671d">&#9670;&nbsp;</a></span>mutable_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::mutable_iterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a const_iterator to an iterator. </p>

</div>
</div>
<a id="adc4c67f752a07ced3348b0bc9a5afa3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc4c67f752a07ced3348b0bc9a5afa3a">&#9670;&nbsp;</a></span>nth() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::nth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Requires index &lt;= <a class="el" href="classtsl_1_1ordered__set.html#a1fa37a53d11a5076aaeb33353028f4d7">size()</a>.</p>
<p>Return an iterator to the element at index. Return <a class="el" href="classtsl_1_1ordered__set.html#a5aa697b0fafb7028551f4d4f66381ca8">end()</a> if index == <a class="el" href="classtsl_1_1ordered__set.html#a1fa37a53d11a5076aaeb33353028f4d7">size()</a>. </p>

</div>
</div>
<a id="aba2011ea9a10cc9f3e51fea95580abe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba2011ea9a10cc9f3e51fea95580abe1">&#9670;&nbsp;</a></span>nth() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::nth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Requires index &lt;= <a class="el" href="classtsl_1_1ordered__set.html#a1fa37a53d11a5076aaeb33353028f4d7">size()</a>.</p>
<p>Return an iterator to the element at index. Return <a class="el" href="classtsl_1_1ordered__set.html#a5aa697b0fafb7028551f4d4f66381ca8">end()</a> if index == <a class="el" href="classtsl_1_1ordered__set.html#a1fa37a53d11a5076aaeb33353028f4d7">size()</a>. </p>

</div>
</div>
<a id="a4e545a2e1c9252da9aafd3b8d9027996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e545a2e1c9252da9aafd3b8d9027996">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a>&amp; <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classtsl_1_1ordered__set.html#aa3852aebb63dcde9d151859cb65f951e">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>ilist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae440c07d0c3401bb8a1e672cda9d39d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae440c07d0c3401bb8a1e672cda9d39d8">&#9670;&nbsp;</a></span>pop_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5e062f9c1505b58ad17726d9accdfa21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e062f9c1505b58ad17726d9accdfa21">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a850e708a94572268b80d79d8238c74fd">reverse_iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad2b6e77078a912cfaea9ebc45e876aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2b6e77078a912cfaea9ebc45e876aea">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#ac4cdc912734a2b6757cbb816ab2657ea">const_reverse_iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa37e8d6244ab4f608e00b619e14433a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa37e8d6244ab4f608e00b619e14433a5">&#9670;&nbsp;</a></span>rcbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#ac4cdc912734a2b6757cbb816ab2657ea">const_reverse_iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::rcbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4bad2ff2e0a44fc871f8350b44a40e16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bad2ff2e0a44fc871f8350b44a40e16">&#9670;&nbsp;</a></span>rcend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#ac4cdc912734a2b6757cbb816ab2657ea">const_reverse_iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::rcend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acc309424677397325af4476ac31e1500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc309424677397325af4476ac31e1500">&#9670;&nbsp;</a></span>rehash()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::rehash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae499a978d0a0aec34cdc37ade4137aff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae499a978d0a0aec34cdc37ade4137aff">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a850e708a94572268b80d79d8238c74fd">reverse_iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa0d74ddd51e82e4b632057b69935b116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0d74ddd51e82e4b632057b69935b116">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#ac4cdc912734a2b6757cbb816ab2657ea">const_reverse_iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab9a62a8db59d69fb9b6f930c15427a0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9a62a8db59d69fb9b6f930c15427a0e">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a50408f6297bc6ecb05c7a0942bb581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a50408f6297bc6ecb05c7a0942bb581">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<div class="memtemplate">
template&lt;class Serializer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::serialize </td>
          <td>(</td>
          <td class="paramtype">Serializer &amp;&#160;</td>
          <td class="paramname"><em>serializer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Serialize the set through the <code>serializer</code> parameter.</p>
<p>The <code>serializer</code> parameter must be a function object that supports the following call:</p><ul>
<li><code>void operator()(const U&amp; value);</code> where the types <code>std::uint64_t</code>, <code>float</code> and <code>Key</code> must be supported for U.</li>
</ul>
<p>The implementation leaves binary compatibilty (endianness, IEEE 754 for floats, ...) of the types it serializes in the hands of the <code>Serializer</code> function object if compatibilty is required. </p>

</div>
</div>
<a id="ad3f1cb2ec551059e1316532205c461a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3f1cb2ec551059e1316532205c461a7">&#9670;&nbsp;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1fa37a53d11a5076aaeb33353028f4d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa37a53d11a5076aaeb33353028f4d7">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac2982b9af31dc0cfc8a9eccd9fe325fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2982b9af31dc0cfc8a9eccd9fe325fc">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a96fc16543a99e892512b9119375c0fe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96fc16543a99e892512b9119375c0fe5">&#9670;&nbsp;</a></span>unordered_erase() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::unordered_erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Faster erase operation with an O(1) average complexity but it doesn't preserve the insertion order.</p>
<p>If an erasure occurs, the last element of the map will take the place of the erased element. </p>

</div>
</div>
<a id="a4c0e19fd5e5e8832c522b6f876d2a7f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c0e19fd5e5e8832c522b6f876d2a7f9">&#9670;&nbsp;</a></span>unordered_erase() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a6b02aa2270e720edf5b8a30b106e7346">iterator</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::unordered_erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html#a3a1996923ed0d9b62d7d959af57a1be3">const_iterator</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Faster erase operation with an O(1) average complexity but it doesn't preserve the insertion order.</p>
<p>If an erasure occurs, the last element of the map will take the place of the erased element. </p>

</div>
</div>
<a id="ae89a8c07da6b74f3dd737a77366d49cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae89a8c07da6b74f3dd737a77366d49cf">&#9670;&nbsp;</a></span>unordered_erase() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::unordered_erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1ordered__set.html#a02fb4e2e15f314f6ac35c214d9df23ef">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Faster erase operation with an O(1) average complexity but it doesn't preserve the insertion order.</p>
<p>If an erasure occurs, the last element of the map will take the place of the erased element. </p>

</div>
</div>
<a id="a9b291ce4c12967996a10646ded0d352c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b291ce4c12967996a10646ded0d352c">&#9670;&nbsp;</a></span>unordered_erase() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::unordered_erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1ordered__set.html#a02fb4e2e15f314f6ac35c214d9df23ef">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Faster erase operation with an O(1) average complexity but it doesn't preserve the insertion order.</p>
<p>If an erasure occurs, the last element of the map will take the place of the erased element.</p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1ordered__set.html#a7582155198c43ed0328394c589274a31">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a2b30fbcf395a674198bc7943bb04d756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b30fbcf395a674198bc7943bb04d756">&#9670;&nbsp;</a></span>unordered_erase() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::unordered_erase </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Faster erase operation with an O(1) average complexity but it doesn't preserve the insertion order.</p>
<p>If an erasure occurs, the last element of the map will take the place of the erased element.</p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key. </p>

</div>
</div>
<a id="a979b730573d4d61fd42df217b8bccd20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a979b730573d4d61fd42df217b8bccd20">&#9670;&nbsp;</a></span>unordered_erase() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<div class="memtemplate">
template&lt;class K , class KE  = KeyEqual, typename std::enable_if&lt; has_is_transparent&lt; KE &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtsl_1_1ordered__set.html#a2679e2e7b1ac5583afe30254f3fe2391">size_type</a> <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::unordered_erase </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>precalculated_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Faster erase operation with an O(1) average complexity but it doesn't preserve the insertion order.</p>
<p>If an erasure occurs, the last element of the map will take the place of the erased element.</p>
<p>This overload only participates in the overload resolution if the typedef KeyEqual::is_transparent exists. If so, K must be hashable and comparable to Key.</p>
<p>Use the hash value 'precalculated_hash' instead of hashing the key. The hash value should be the same as <a class="el" href="classtsl_1_1ordered__set.html#a7582155198c43ed0328394c589274a31">hash_function()</a>(key). Usefull to speed-up the lookup if you already have the hash. </p>

</div>
</div>
<a id="a1bc951514a5c4c29c14b6cf5177cf1ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bc951514a5c4c29c14b6cf5177cf1ec">&#9670;&nbsp;</a></span>values_container()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtsl_1_1ordered__set.html#af68942b7edb65da7c0ec756b7172f497">values_container_type</a>&amp; <a class="el" href="classtsl_1_1ordered__set.html">tsl::ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt;::values_container </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the container in which the values are stored. The values are in the same order as the insertion order and are contiguous in the structure, no holes (<a class="el" href="classtsl_1_1ordered__set.html#a1fa37a53d11a5076aaeb33353028f4d7">size()</a> == <a class="el" href="classtsl_1_1ordered__set.html#a1bc951514a5c4c29c14b6cf5177cf1ec">values_container()</a>.<a class="el" href="classtsl_1_1ordered__set.html#a1fa37a53d11a5076aaeb33353028f4d7">size()</a>). </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="aafca13b71af5e35082b3e22c01680844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafca13b71af5e35082b3e22c01680844">&#9670;&nbsp;</a></span>operator!=</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad685a66cbb7c59a0923ca7d57a734c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad685a66cbb7c59a0923ca7d57a734c27">&#9670;&nbsp;</a></span>operator<</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a506164f732a96dfefef194dd47c5459d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a506164f732a96dfefef194dd47c5459d">&#9670;&nbsp;</a></span>operator<=</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa58b43c0c001cea18c9b7d7714b9d85c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa58b43c0c001cea18c9b7d7714b9d85c">&#9670;&nbsp;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a59796ffdc4400bdcb82073c952cdf451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59796ffdc4400bdcb82073c952cdf451">&#9670;&nbsp;</a></span>operator></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a94a17aeb7a1827b4f3cc26552ddb9db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94a17aeb7a1827b4f3cc26552ddb9db0">&#9670;&nbsp;</a></span>operator>=</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5fb2c2dd5207da0a8b606fc11fa6dba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb2c2dd5207da0a8b606fc11fa6dba8">&#9670;&nbsp;</a></span>swap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Key , class Hash  = std::hash&lt;Key&gt;, class KeyEqual  = std::equal_to&lt;Key&gt;, class Allocator  = std::allocator&lt;Key&gt;, class ValueTypeContainer  = std::deque&lt;Key, Allocator&gt;, class IndexType  = std::uint_least32_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtsl_1_1ordered__set.html">ordered_set</a>&lt; Key, Hash, KeyEqual, Allocator, ValueTypeContainer, IndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/tsl/<a class="el" href="ordered__set_8h_source.html">ordered_set.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
